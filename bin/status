#!/usr/bin/env python3

from subprocess import run as shell_run, CalledProcessError
from pathlib import Path
from pprint import pprint
from sys import stderr
from datetime import datetime
from functools import cached_property
from abc import ABC, abstractmethod
from enum import Enum, auto
import json

import colorful
import click
from click import style
from tabulate import tabulate


USER = "alissa-huskey"
REPO = "python-class"
DATA_DIR = Path(__file__).absolute().parent.parent.joinpath("tmp", "github-data")
TODAY = datetime.today().strftime("%Y-%m-%d-%s")
VERBOSE = False  ; VERBOSE = True



def rget(source, keys):
    """Get a value from nested dictionaries.
       Params
       ------
       * source (dict)   : (possibly) nested dictionary
       * keys (str, list): a string of nested keys seperated by "." or the
                           resulting list split from such a string
       Returns
       -------
       (Any) The final value

       Examples
       -------
       >>> org = {'ops': { 'manager': "Joe Smith"}, 'manager': "Bill Jones"}
       >>> rget(org, "manager")
       'Bill Jones'
       >>> rget(org, "ops.manager")
       'Joe Smith'
    """

    # Return None for empty keys
    if not keys or not source: return

    # split {keys} strings by "."
    if isinstance(keys, str):
        keys = keys.split(".")

    # get the first key from the list
    this_key = keys.pop(0)

    # recursively call rget() if there are keys remaining
    if len(keys):
        return rget(source.get(this_key, {}), keys)

    # if this was the last key, return the final value
    else:
        return source.get(this_key)

class App():
    """Class for the top level app."""

    def info(self, *args, name=None):
        """Print info message
           If optional {name} is passed, put it at the beginning of the message highlighted.
        """
        if not VERBOSE:
            return
        prefix = [style("[Info]", fg="cyan")]
        if name:
            prefix.append(f"{colorful.yellow}{name:<12}{colorful.reset}:")
        print(*prefix, *args, file=stderr)

    def abort(self, *args):
        """Print an error message and exit with status code 1"""
        print(colorful.red("Error"), *args, file=stderr)
        exit(1)

    @cached_property
    def style(self):
        return Style()

class Style():
    SUCCESS_SYMBOL = "\u2713" # ✓
    FAILURE_SYMBOL = "\u2717" # ✗

    def header(self, title):
        """Return a styled header"""
        title = style(title, bold=True) 
        return f"\n{title}\n"

    def status(self, status):
        """Return a colored unicode symbol cooresponding to the Status object"""
        return self.success if status.ok else self.fail

    @property
    def success(self):
        """Return a green unicode check mark"""
        return style(self.SUCCESS_SYMBOL, fg="green")

    @property
    def fail(self):
        """Return a red unicode x"""
        return style(self.FAILURE_SYMBOL, fg="red")


class AbstractState(Enum):
    """Abstract class for state-like Enum objects.
       Provides instanciation by name and an abstract ok() method.
    """
    def __str__(self):
        return self.name

    @classmethod
    def _missing_(cls, value):
        matches = [match for name, match in cls.__members__.items()
                    if name.lower() == value.lower()]
        if matches:
            return matches[0]
        super()._missing_(value)


    @property
    @abstractmethod
    def ok(self) -> bool:
        """Return True if the object indicates success."""


# conclusion: success, failure, neutral, cancelled, skipped, timed_out, or action_require
# DeployStatuse: (states: error, failure, pending, in_progress, queued, or success)
# Run: "status" queued, in_progress, or completed.
# Run: "conclusion" ..? "success"
# Step: "conclusion" ...?

class Progress(AbstractState):
    """Class for progress statuses."""
    queued, in_progress, completed = auto(), auto(), auto()

    @property
    def ok(self):
        return self == Progress.completed

class Status(AbstractState):
    """Class for success statuses."""
    error = auto()
    failure = auto()
    pending = auto()
    in_progress = auto()
    queued = auto()
    success = auto()

    @property
    def ok(self):
        return self.name == "success"


class Date(datetime):
    """Class for date strings"""

    """The format used by datetime.strptime() to parse date strings."""
    INPUT_FORMAT: str = "%Y-%m-%dT%H:%M:%SZ"

    def __new__(cls, *args):
        if isinstance(datestr := args[0], str):
            return super(Date, cls).strptime(datestr, cls.INPUT_FORMAT)
        else:
            return super().__new__(cls, *args)

    def __repr__(self):
        return f"Date({self})"

    def __str__(self):
        return(str(self.date()))


class Sha(str):
    """Class for git commit SHA strings
    Examples
    --------
    >>> sha = Sha("dfe4c0a60db827a8576bb510f99d574f9a42be4d")
    >>> str(sha)
    'dfe4c0a'
    >>> sha.full
    'dfe4c0a60db827a8576bb510f99d574f9a42be4d'
    """

    SHORT_LENGTH: int = 7

    def __new__(cls, content):
        inst = str.__new__(cls, content)
        inst.full = content
        return inst

    def __repr__(self):
        """Provide trimmed sha string"""
        return repr(str(self))

    def __str__(self):
        """Provide trimmed sha string"""
        if len(self) <= self.SHORT_LENGTH:
          return self

        return self[0:self.SHORT_LENGTH]


class Object(ABC):
    """Base class for objects created from the json data received from
       the github API."""

    """Application object"""
    APP: App

    """The data imported from the request."""
    request_data: dict

    def __repr__(self):
        """Return repr string containing values of attrs as defined in
           self.fields"""
        fields = { k: getattr(self, k) for
                   k,v in self.fields.items() if self.fields[k][1] }
        if fields:
            return f"{self.__class__.__name__}({fields!r})"
        else:
            return f"{self.__class__.__name__}()"

    def __init__(self, data: dict):
        """Initializer
           Extracts the values from the {data} dict as defined in by {self.fields}.

           Params
           ------
           data: (dict) the Json data received from GitHub
        """
        self.request_data = data
        for attr, mapping in self.fields.items():
            key = mapping[0]
            if not key:
              continue
            klass = mapping[2] if len(mapping) >= 3 else None
            val = rget(data, key)
            if klass and val:
              val = klass(val)
            setattr(self, attr, val)

    @property
    def ok(self):
        """Return True if all attrs progress and status are True"""
        states = [ getattr(self, attr).ok
                  for attr in ("progress", "status")
                  if hasattr(self, attr) ]
        self.APP.info(states, name=f"{self.__class__.__name__} ok(): states")
        return all(states)

    @property
    @abstractmethod
    def fields(self) -> dict:
      """Return a dict, where
         * key (str): object attribute to set
         * value (tuple):
           * (str) key to the cooresponding field from the JSON dict
           * (bool) if it should be included in the repr
           * (type, optional) type to instantiate attr as
      """


class ChildObject(Object):
    """Base class for objects that need to keep track of their parent object."""

    def __init__(self, data, parent):
        """Initializer
           Assigns self.parent

           Params
           ------
           data: (dict) the Json data received from GitHub
           parent: (Object) the parent object
        """
        super().__init__(data)
        self.parent = parent


class DeployStatus(Object):
    """Object class for the deploy status."""

    @property
    def fields(self) -> dict:
      return {
        'id': ("id", True),
        'date': ("created_at", True, Date),
        'status': ("state", True, Status),
      }


class Run(Object):
    """Object class for workflow runs."""

    @property
    def fields(self) -> dict:
      return dict(
          id=("id", True),
          workflow_id=("workflow_id", False),
          number=("run_number", True),
          date=("created_at", True, Date),
          sha=("head_sha", False, Sha),
          job=("name", False),
          progress=("status", False, Progress),
          status=("conclusion", True, Status),
          branch=("head_branch", False),
          message=("head_commit.message", False),
      )

    @cached_property
    def jobs(self):
      """Return a JobRequest."""
      return self.jobs_request.data

    @cached_property
    def jobs_request(self):
      """Return a JobRequest."""
      return JobsRequest(self)

    @property
    def last_step(self) -> str:
        """Return the last successful step or first failed step for this run"""
        if self.ok:
            return self.jobs[-1].steps[-1]
        failed = [s for job in self.jobs for s in job.steps if not s.ok]
        return failed[0]

    def deploy(self, deploys: list) -> str:
        """Return Deploy object from list of {deploys} with master_sha matching
           self.sha"""
        if not self.ok:
            return
        res = [d for d in deploys if d.master_sha == self.sha]
        return res[0] if res else None

class Step(ChildObject):
    """Object class for steps, child of Job."""

    @property
    def fields(self) -> dict:
      return dict(
          number=("number", True),
          status=("conclusion", True, Status),
          desc=("name", True),
      )


class Job(ChildObject):
    """Object class for jobs, child of Run."""

    @property
    def fields(self) -> dict:
      return dict(
        id=("id", True),
        progress=("status", False, Progress),
        status=("conclusion", True, Status),
        sha=("head_sha", True, Sha),
        name=("name", False),
      )

    @property
    def steps(self) -> list:
      return [Step(x, self) for x in self.request_data["steps"]]


class Commit(Object):
    """Class for commits."""

    @property
    def fields(self) -> dict:
      return dict(
        sha=("sha", True, Sha),
        date=("commit.author.date", True, Date),
        author=("commit.author.name", True),
        committer=("commit.committer.name", False),
        message=("commit.message", False),
        tree=("commit.tree.sha", False, Sha),
        stats=("stats", False),
        files=("files", False),
      )


class Deploy(Object):
    """Class for deploys."""

    @property
    def fields(self) -> dict:
      return dict(
        id=("id", True),
        sha=("sha", True, Sha),
        date=("created_at", True, Date),
        creator=("creator.login", False),
        status=(None, True, Status),
        master_sha=(None, True, Sha),
      )

    @cached_property
    def commit_request(self):
        """Return CommitRequest object"""
        return CommitRequest(self.sha)

    @cached_property
    def commit(self):
        """Return Commit object"""
        return self.commit_request.data

    @property
    def message(self):
        """Return commit.message without self.master_sha"""
        if not self.master_sha:
            return self.commit.message
        if end := self.commit.message.rindex(f" {self.master_sha.full}"):
            return self.commit.message[0:end]
        return self.commit.message

    @property
    def master_sha(self) -> str:
      """Returns a string with the sha from the master branch, parsed from the
         message of the deploy commit
      """
      if not self.commit.message:
        return
      sha = self.commit.message.split()[-1]
      if len(sha) == 40:
        return Sha(sha)

    @property
    def status(self) -> str:
      if not self.statuses:
        return
      return Status(self.statuses[0].status)

    @cached_property
    def statuses(self):
      """Returns list of Status objects"""
      return self.statuses_request.data

    @cached_property
    def statuses_request(self):
      """Returns a StatusRequest"""
      return StatusRequest(self)


class GithubRequest(ABC):
    """Abstract base class for requests to the Github API."""

    """Application object"""
    APP: App

    """Name of the directory under {DATA_DIR} to store json files."""
    dirname: str

    """The parsed data received from the Github API."""
    data: list

    def __init__(self):
        """Initializer
           Requests and stores a file if needed, then loads the data from
           either an existing file or the one just created.
        """
        if not self.dirpath.is_dir():
          self.dirpath.mkdir(parents=True)
        if not self.exists():
            self.get()
        self.load()

    @property
    @abstractmethod
    def data(self):
        """Method to assign self.data to Object(s) created from request data.
           Params
           ------
           data: (dict, list) data received from the Github API request.
        """

    @property
    @abstractmethod
    def endpoint(self) -> str:
      """A string containing the part of the Github API endpoint for this
         request type that follows {REPO}.

         For example, if the full endpoint for the class was:
         /repos/{owner}/{repo}/commits/{ref}

         This method would return:
         f"commits/{ref}"
         """

    @cached_property
    def dirpath(self):
        """Returns a Path object to the directory where the json files for this
           API request type are stored."""
        return DATA_DIR.joinpath(self.dirname)

    def exists(self):
      """Return True if there are files downoaded for this request type."""
      return bool(self.files)

    @property
    def files(self):
        """List of json files for this API request type.
           Not cached, as it will need to be refreshed after a new file has
           been created using self.get().
        """
        files = list(self.dirpath.glob("*.json"))
        files.sort(reverse=True)
        return files

    @property
    def default_filepath(self):
        """Returns a Path object to the file to create."""
        return self.dirpath.joinpath(f"{TODAY}.json")

    @cached_property
    def filepath(self):
        """Returns a Path object to either an existing file or the file to
           create."""
        if self.files:
          return self.files[0]

        return self.default_filepath

    def load(self):
        """Load self.data from the most recent .json file in self.dirpath"""
        if not self.filepath.is_file():
          return

        with self.filepath.open() as fp:
          self.request_data = json.load(fp)

    def get(self):
        """Make a request to the Github API then save the resulting json file.
           Uses the `gh` CLI tool to avoid dealing with authentication.
           Raises CalledProcessError if the request fails.
        """
        result = shell_run(["gh", "api", f"/repos/{USER}/{REPO}/{self.endpoint}"],
                     capture_output=True)
        result.check_returncode()
        data = json.loads(result.stdout.decode())
        with self.filepath.open("w") as fp:
          json.dump(data, fp)


class ChildRequest(GithubRequest):
    """Base class for github requests that need to keep track of their parent
       object."""

    parent: None

    def __init__(self, parent):
        """Initializer
           Assigns self.parent.
        """
        self.parent = parent
        super().__init__()

    def exists(self):
      """Return True if there are files downoaded for this request type."""
      return self.filepath.is_file()

    @property
    def filepath(self):
        """Filename is the `{self.parent.id}.json`.'"""
        return self.dirpath.joinpath(f"{self.parent.id}.json")


class StatusRequest(ChildRequest):
    """Class for deploy status requests.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#get-a-deployment-status
    """
    dirname: str = "statuses"

    @property
    def data(self):
        """Returns list of DeployStatus objects."""
        return [ DeployStatus(x) for x in self.request_data ]

    @property
    def endpoint(self):
      """API endpoint following REPO"""
      return f"deployments/{self.parent.id}/statuses"


class JobsRequest(ChildRequest):
    """Class for requesting a list of workflow run jobs.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/actions#list-jobs-for-a-workflow-run
    """

    dirname: str = "jobs"

    @property
    def data(self):
        """Set data to a list of Job objects."""
        return [ Job(x, self.parent) for x in self.request_data["jobs"] ]

    @property
    def endpoint(self):
      """The job runs endpoint."""
      return f"actions/runs/{self.parent.id}/jobs"


class CommitRequest(GithubRequest):
    """Class for requesting a commit.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#get-a-commit
    """

    dirname: str = "commits"

    def __init__(self, ref):
        """Initializer
           Assigns self.ref.
        """
        if isinstance(ref, Sha):
          ref = ref.full

        self.ref = ref
        super().__init__()

    @cached_property
    def filepath(self):
      """Filename uses {self.ref}"""
      return self.dirpath.joinpath(f"{self.ref}.json")

    def exists(self):
      """Return True if there are files downoaded for this request type."""
      return self.filepath.is_file()

    @property
    def data(self):
        """Return a Commit object."""
        return Commit(self.request_data)

    @property
    def endpoint(self):
      """deployments endpoint"""
      return f"commits/{self.ref}"


class DeploysRequest(GithubRequest):
    """Class for requesting a list of deployments.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#deployments
    """

    dirname: str = "deploys"

    @property
    def data(self):
        """Returns a list of Deploy objects."""
        return [ Deploy(x) for x in self.request_data ]

    @property
    def endpoint(self):
      """deployments endpoint"""
      return "deployments"


class RunsRequest(GithubRequest):
    """Class for requesting a list workflow runs.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/actions#workflow-runs
    """

    dirname: str = "runs"

    @property
    def data(self):
        """Returns a list of Run objects."""
        return [ Run(x) for x in self.request_data["workflow_runs"] ]

    @property
    def endpoint(self):
      """Runs endpoint."""
      return "actions/runs"



def debug(app):
    deploys = DeploysRequest()
    statuses = StatusRequest(deploys.data[0])
    runs = RunsRequest()
    run = runs.data[0]
    job = run.jobs[0]
    step = job.steps[0]
    commit_req = CommitRequest("dfe4c0a60db827a8576bb510f99d574f9a42be4d")
    commit = commit_req.data
    status = Status("success")
    progress = Progress("completed")

    app.info(DATA_DIR, name="DATA_DIR")
    app.info(deploys.dirname, name="deploys.dirname")
    app.info(deploys.dirpath, name="deploys.dirpath")
    app.info(deploys.filepath, name="deploys.filepath")
    app.info(deploys.endpoint, name="deploys.endpoint")
    app.info(deploys.data[0], name="Deploy")

    app.info(statuses.dirname, name="statuses.dirname")
    app.info(statuses.dirpath, name="statuses.dirpath")
    app.info(statuses.filepath, name="statuses.filepath")
    app.info(statuses.endpoint, name="statuses.endpoint")
    app.info(statuses.data[0], name="DeployStatus")

    app.info(runs.dirname, name="runs.dirname")
    app.info(runs.dirpath, name="runs.dirpath")
    app.info(runs.filepath, name="runs.filepath")
    app.info(runs.endpoint, name="runs.endpoint")
    app.info(runs.data[0], name="Run")

    app.info( run.jobs_request.dirname, name="jobs.dirname")
    app.info( run.jobs_request.dirpath, name="jobs.dirpath")
    app.info(run.jobs_request.filepath, name="jobs.filepath")
    app.info(run.jobs_request.endpoint, name="jobs.endpoint")
    app.info(job, name="Job")

    app.info( run.jobs_request.dirname, name="jobs.dirname")
    app.info( run.jobs_request.dirpath, name="jobs.dirpath")
    app.info(run.jobs_request.filepath, name="jobs.filepath")
    app.info(run.jobs_request.endpoint, name="jobs.endpoint")
    app.info(step, name="Step")
    app.info(commit, name="Commit")
    app.info(status, status.ok, name="Status")
    app.info(progress, progress.ok, name="Progress")


def main():
    """Do the stuff"""
    app = Object.APP = GithubRequest.APP = App()
    # debug(app)

    deploys = DeploysRequest()
    runs = RunsRequest()

    rows = []
    for run in runs.data:
        deploy = run.deploy(deploys.data)
        rows.append({
            "#": run.number,
            "OK": app.style.status(run.status),
            "date": run.date,
            "commit": run.sha,
            "message": run.message,
            "step": f"#{run.last_step.number:>2} {app.style.status(run.last_step)} {run.last_step.desc}",
            "deploy": f"{app.style.status(deploy.status)} {deploy.sha}" if deploy else ""
        })

    print(app.style.header("Runs"))
    print(tabulate(rows, headers="keys"))

    rows = []
    for deploy in deploys.data:
        rows.append({
            "OK": app.style.status(deploy.status),
            "date": deploy.date,
            "id": deploy.id,
            "commit": deploy.sha,
            "master": deploy.master_sha or " "*Sha.SHORT_LENGTH,
            "message": deploy.message,
        })

    print(app.style.header("Deploys"))
    print(tabulate(rows, headers="keys"))

if __name__ == "__main__":
    main()
