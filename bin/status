#!/usr/bin/env python3

from subprocess import run as shell_run, CalledProcessError
from pathlib import Path
from pprint import pprint
from sys import stderr
from datetime import datetime
from functools import cached_property
from abc import ABC, abstractmethod
from enum import Enum, IntEnum
import json

import colorful
import click
from click import style
from tabulate import tabulate


USER = "alissa-huskey"
REPO = "python-class"
DATA_DIR = Path(__file__).absolute().parent.parent.joinpath("tmp", "github-data")
TODAY = datetime.today().strftime("%Y-%m-%d-%s")


def rget(source, keys):
    """Get a value from nested dictionaries.
       Params
       ------
       * source (dict)   : (possibly) nested dictionary
       * keys (str, list): a string of nested keys seperated by "." or the
                           resulting list split from such a string
       Returns
       -------
       (Any) The final value

       Examples
       -------
       >>> org = {'ops': { 'manager': "Joe Smith"}, 'manager': "Bill Jones"}
       >>> rget(org, "manager")
       'Bill Jones'
       >>> rget(org, "ops.manager")
       'Joe Smith'
    """

    # Return None for empty keys
    if not keys or not source: return

    # split {keys} strings by "."
    if isinstance(keys, str):
        keys = keys.split(".")

    # get the first key from the list
    this_key = keys.pop(0)

    # recursively call rget() if there are keys remaining
    if len(keys):
        return rget(source.get(this_key, {}), keys)

    # if this was the last key, return the final value
    else:
        return source.get(this_key)

class App():
    """Class for the top level app."""

    def __init__(self, local=False, refresh=False, verbose=False,):
        """Initializer
           Set option attrubites and print messages about enabled options.
        """
        self.force_local = local
        self.refresh = refresh
        self.verbose = verbose

        if self.force_local and self.refresh:
            abort("--local and --refresh are exclusive")

        # TODO: This should probably only be printed in verbose mode, or at
        #       least not quite.
        self.msg(self.style.mode("verbose", self.verbose))
        self.msg(self.style.mode("local", self.force_local))
        self.msg(self.style.mode("refresh", self.refresh))

    def msg(self, *args):
        """Print message
           If optional {name} is passed, put it at the beginning of the message highlighted.
        """
        if not [a for a in args if a]:
            return
        print(style(">", fg="cyan"), *args)

    def info(self, *args, name=None):
        """Print info message
           If optional {name} is passed, put it at the beginning of the message highlighted.
        """
        if not self.verbose:
            return
        prefix = [style("[Info]", fg="cyan")]
        if name:
            prefix.append(f"{colorful.yellow}{name:<12}{colorful.reset}:")
        print(*prefix, *args, file=stderr)

    def abort(self, *args):
        """Print an error message and exit with status code 1"""
        print(colorful.red("Error"), *args, file=stderr)
        exit(1)

    @cached_property
    def style(self):
        return Style()


class Ok(IntEnum):
    """Simplified statuses, """
    busy   =  0  # pending, queued, in-progress
    ok     =  1  # success, built, completed
    fail   = -1  # error, failure
    error  = -2  # invalid state name


# error, failure, pending, in_progress, queued, or success
# queued, in_progress, or completed.
# success, failure, neutral, cancelled, skipped, timed_out, or action_require
class AbstractState(bytes, Enum):
    """Abstract class for state-like Enum objects.
       Provides instanciation by name and an abstract ok() method.
    """

    def __new__(cls, value, is_ok=None):
        obj = bytes.__new__(cls, [value])
        obj._value_ = value
        obj.ok = is_ok
        return obj

    @classmethod
    def _missing_(cls, value):
        matches = [match for name, match in cls.__members__.items()
                    if name.lower() == value.lower()]
        if matches:
            return matches[0]
        super()._missing_(value)

class Progress(AbstractState):
    """Class for progress statuses."""
    queued       = (1, Ok.busy)
    in_progress  = (2, Ok.busy)
    completed    = (3, Ok.ok)


class BuildStatus(AbstractState):
    """Class for build statuses.
       Used for Gihub Pages.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#pages
    """
    null      = (1, Ok.busy)
    queued    = (2, Ok.busy)
    building  = (3, Ok.busy)
    built     = (4, Ok.ok)
    errored   = (5, Ok.fail)


class Status(AbstractState):
    """Class for success statuses.
       Used for deploy statuses, probably workflow jobs.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#deployments
    """
    error        = (1, Ok.fail)
    failure      = (2, Ok.fail)
    pending      = (3, Ok.busy)
    in_progress  = (4, Ok.busy)
    queued       = (5, Ok.busy)
    success      = (6, Ok.ok)


class Style():
    """Class for styling output"""

    OK_SYMBOL     = "\u2714" # ✓
    FAIL_SYMBOL   = "\u2717" # ✗
    BUSY_SYMBOL   = "\u26AC" # ⚬
    ERROR_SYMBOL  = "\u26A0" # ⚠

    STATUS_STYLES = {
         Ok.busy:  (BUSY_SYMBOL,  "yellow"),
         Ok.ok:    (OK_SYMBOL,    "green"),
         Ok.fail:  (FAIL_SYMBOL,  "red"),
         Ok.error: (ERROR_SYMBOL, "red"),
    }

    def header(self, title):
        """Return a styled header"""
        title = style(title, bold=True)
        return f"\n{title}\n"

    def status(self, obj):
        """Return a colored unicode symbol cooresponding to the Status object"""
        assert hasattr(obj, "ok"), f"Object {obj!r} has no property 'ok'."
        assert obj.ok in self.STATUS_STYLES, \
            f"Undefined STATUS_STYLES key for object {obj!r} with ok value {obj.ok}"

        symbol, color = self.STATUS_STYLES[obj.ok]
        return style(symbol, fg=color)

    def job(self, job) -> str:
        """Return a string that prints the job status symbol and last step info"""
        if not job:
            return "-"
        return f"{self.status(job)} {self.step(job.last_step)}"

    def mode(self, name, enabled) -> str:
        """Return message indicating a mode was enabled"""
        if enabled:
            return f"{name.capitalize()} mode enabled."

    def step(self, step) -> str:
        """."""
        num, desc = "-", "-"
        if step:
            num, desc = step.number, step.desc[0:20]
        return f"{num:>2} {desc}"


class Date(datetime):
    """Class for date strings"""

    """The format used by datetime.strptime() to parse date strings."""
    INPUT_FORMAT: str = "%Y-%m-%dT%H:%M:%SZ"

    def __new__(cls, *args):
        if isinstance(datestr := args[0], str):
            return super(Date, cls).strptime(datestr, cls.INPUT_FORMAT)
        else:
            return super().__new__(cls, *args)

    def __repr__(self):
        return f"Date({self})"

    def __str__(self):
        return(str(self.date()))


class Sha(str):
    """Class for git commit SHA strings
    Examples
    --------
    >>> sha = Sha("dfe4c0a60db827a8576bb510f99d574f9a42be4d")
    >>> str(sha)
    'dfe4c0a'
    >>> sha.full
    'dfe4c0a60db827a8576bb510f99d574f9a42be4d'
    """

    SHORT_LENGTH: int = 7

    def __new__(cls, content):
        inst = str.__new__(cls, content)
        inst.full = content
        return inst

    def __repr__(self):
        """Provide trimmed sha string"""
        return repr(str(self))

    def __str__(self):
        """Provide trimmed sha string"""
        if len(self) <= self.SHORT_LENGTH:
          return self

        return self[0:self.SHORT_LENGTH]


class Object(ABC):
    """Base class for objects created from the json data received from
       the github API."""

    """Application object"""
    APP: App

    """The data imported from the request."""
    request_data: dict

    def __repr__(self):
        """Return repr string containing values of attrs as defined in
           self.fields"""
        fields = { k: getattr(self, k) for
                   k,v in self.fields.items() if self.fields[k][1] }
        if fields:
            return f"{self.__class__.__name__}({fields!r})"
        else:
            return f"{self.__class__.__name__}()"

    def __init__(self, data: dict):
        """Initializer
           Extracts the values from the {data} dict as defined in by {self.fields}.

           Params
           ------
           data: (dict) the Json data received from GitHub
        """
        self.request_data = data
        for attr, mapping in self.fields.items():
            key = mapping[0]
            if not key:
              continue
            klass = mapping[2] if len(mapping) >= 3 else None
            val = rget(data, key)
            if klass and val:
              val = klass(val)
            setattr(self, attr, val)

    @property
    def states(self):
        """Return generator of all defined attrs progress, status"""
        return (getattr(self, attr)
                for attr in ("progress", "status")
                if hasattr(self, attr))

    @property
    def is_ok(self) -> bool:
        """Return True if all states are Ok.ok"""
        return all( (state and state.ok == Ok.ok for state in self.states) )

    @property
    def ok(self):
        """Return most problematic ok value of any defined and set states"""
        return min((state.ok for state in self.states if state))

    @property
    def is_open(self):
        """Return True if any states None or Ok.busy"""
        return any( (not state or state.ok == Ok.busy for state in self.states) )

    @property
    @abstractmethod
    def fields(self) -> dict:
      """Return a dict, where
         * key (str): object attribute to set
         * value (tuple):
           * (str) key to the cooresponding field from the JSON dict
           * (bool) if it should be included in the repr
           * (type, optional) type to instantiate attr as
      """


class ChildObject(Object):
    """Base class for objects that need to keep track of their parent object."""

    def __init__(self, data, parent):
        """Initializer
           Assigns self.parent

           Params
           ------
           data: (dict) the Json data received from GitHub
           parent: (Object) the parent object
        """
        super().__init__(data)
        self.parent = parent


class DeployStatus(Object):
    """Object class for the deploy status."""

    @property
    def fields(self) -> dict:
      return {
        'id': ("id", True),
        'date': ("created_at", True, Date),
        'status': ("state", True, Status),
      }


class Run(Object):
    """Object class for workflow runs."""

    @property
    def fields(self) -> dict:
      return dict(
          id=("id", True),
          workflow_id=("workflow_id", False),
          number=("run_number", True),
          date=("created_at", True, Date),
          sha=("head_sha", False, Sha),
          job=("name", False),
          progress=("status", False, Progress),
          status=("conclusion", True, Status),
          branch=("head_branch", False),
          message=("head_commit.message", False),
      )

    @cached_property
    def jobs(self):
      """Return a JobRequest."""
      return self.jobs_request.data

    @cached_property
    def jobs_request(self):
      """Return a JobRequest."""
      return JobsRequest(self)

    @property
    def last_job(self) -> str:
        """Return the last successful job or first failed job for this job"""
        if not self.jobs:
            return
        if not self.is_ok:
            failed = [job for job in self.jobs if not job.is_ok]
            if failed:
                return failed[0]
        return self.jobs[-1]

    def deploy(self, deploys: list) -> str:
        """Return Deploy object from list of {deploys} with master_sha matching
           self.sha"""
        res = [d for d in deploys if d.master_sha == self.sha]
        return res[0] if res else None


class Step(ChildObject):
    """Object class for steps, child of Job."""

    @property
    def fields(self) -> dict:
      return dict(
          number=("number", True),
          status=("conclusion", True, Status),
          desc=("name", True),
      )


class Pages(Object):
    """Object class for Github Pages info."""

    @property
    def fields(self) -> dict:
      return dict(
        url=("html_url", True),
        branch=("source.branch", True),
        path=("source.path", True),
        status=("status", True, BuildStatus),
      )

    @property
    def steps(self) -> list:
      return [Step(x, self) for x in self.request_data["steps"]]


class Job(ChildObject):
    """Object class for jobs, child of Run."""

    @property
    def fields(self) -> dict:
      return dict(
        id=("id", True),
        progress=("status", False, Progress),
        status=("conclusion", False, Status),
        sha=("head_sha", True, Sha),
        name=("name", False),
        ok=(None, True),
      )

    @property
    def steps(self) -> list:
      return [Step(x, self) for x in self.request_data["steps"]]

    @property
    def last_step(self) -> str:
        """Return the last successful step or first failed step for this run"""
        if not self.steps:
            return
        if not self.is_ok:
            failed = [s for s in self.steps if not s.is_ok]
            if failed:
                return failed[0]
        return self.steps[-1]


class Commit(Object):
    """Class for commits."""

    @property
    def fields(self) -> dict:
      return dict(
        sha=("sha", True, Sha),
        date=("commit.author.date", True, Date),
        author=("commit.author.name", True),
        committer=("commit.committer.name", False),
        message=("commit.message", False),
        tree=("commit.tree.sha", False, Sha),
        stats=("stats", False),
        files=("files", False),
      )


class Deploy(Object):
    """Class for deploys."""

    @property
    def fields(self) -> dict:
      return dict(
        id=("id", True),
        sha=("sha", True, Sha),
        date=("created_at", True, Date),
        creator=("creator.login", False),
        status=(None, True, Status),
        master_sha=(None, True, Sha),
      )

    @cached_property
    def commit_request(self):
        """Return CommitRequest object"""
        return CommitRequest(self.sha)

    @cached_property
    def commit(self):
        """Return Commit object"""
        return self.commit_request.data

    @property
    def message(self):
        """Return commit.message without self.master_sha"""
        if not self.master_sha:
            return self.commit.message
        if end := self.commit.message.rindex(f" {self.master_sha.full}"):
            return self.commit.message[0:end]
        return self.commit.message

    @property
    def master_sha(self) -> str:
      """Returns a string with the sha from the master branch, parsed from the
         message of the deploy commit
      """
      if not self.commit.message:
        return
      sha = self.commit.message.split()[-1]
      if len(sha) == 40:
        return Sha(sha)

    @property
    def status(self) -> str:
      if not self.statuses:
        return
      return Status(self.statuses[0].status)

    @cached_property
    def statuses(self):
      """Returns list of Status objects"""
      return self.statuses_request.data

    @cached_property
    def statuses_request(self):
      """Returns a StatusRequest"""
      return StatusRequest(self)


# TODO: Add docstrings
class Downloadable():
    """Abstract base class to provide should_refresh method."""

    def APP(self):
        """."""
        raise Exception("Should be inherited from GithubRequest class, not Downloadable.")

    def is_open(self) -> bool:
        """."""
        raise Exception("Should be inherited from GithubRequest class, not Downloadable.")

    def exists(self) -> bool:
        """."""
        raise Exception("Should be inherited from GithubRequest class, not Downloadable.")

    def should_refresh(self):
        """."""
        raise Exception("Should be inherited from GithubRequest class, not Downloadable.")


class Dynamic(Downloadable):
    """For requests that respond with data that is a snapshot in time."""

    def should_refresh(self):
        """."""
        return self.APP.refresh


class Finite(Downloadable):
    """For requests that respond with data for a single object may be updated
       until it is closed."""

    def should_refresh(self):
        """."""
        if self.APP.force_local:
            return False

        return self.is_open()


class Additive(Downloadable):
    """For requests respond with a list of Finite members which may be added to."""

    def should_refresh(self):
        """."""
        if self.APP.force_local:
            return False

        return self.is_open() or self.APP.refresh


class Static(Downloadable):
    """For requests that do not change once downloaded."""
    def should_refresh(self):
        """."""
        return False


class GithubRequest(ABC, Downloadable):
    """Abstract base class for requests to the Github API."""

    """Application object"""
    APP: App

    """Name of the directory under {DATA_DIR} to store json files."""
    dirname: str

    """The parsed data received from the Github API."""
    data: list

    def __init__(self):
        """Initializer
           Create any missing directories and load JSON data, making an API
           request to download it first if needed.
        """
        if not self.dirpath.is_dir():
          self.dirpath.mkdir(parents=True)
        self.get()

    def __repr__(self):
        return f"{self.__class__.__name__}({self.endpoint})"

    # TODO: Don't refresh if freshly downloaded
    def get(self):
        """Load JSON data, making an API request to download it first if
           needed.
        """
        if not self.exists():
            self.download()

        self.load()

        if self.should_refresh():
            d = [t for t in self.__class__.mro() if not t is Downloadable and issubclass(t, Downloadable) ]
            self.APP.info(self.__class__.__name__, d[-1].__name__, self.endpoint, name="Refreshing")
            self.download()
            self.load()

    def is_open(self) -> bool:
        """."""
        if hasattr(self.data, "is_open"):
            return self.is_open
        else:
            return any((obj.is_open for obj in self.data))

    @property
    @abstractmethod
    def data(self):
        """Method to assign self.data to Object(s) created from request data.
           Params
           ------
           data: (dict, list) data received from the Github API request.
        """

    @property
    @abstractmethod
    def endpoint(self) -> str:
      """A string containing the part of the Github API endpoint for this
         request type that follows {REPO}.

         For example, if the full endpoint for the class was:
         /repos/{owner}/{repo}/commits/{ref}

         This method would return:
         f"commits/{ref}"
         """

    @cached_property
    def dirpath(self):
        """Returns a Path object to the directory where the json files for this
           API request type are stored."""
        return DATA_DIR.joinpath(self.dirname)

    def exists(self):
      """Return True if there are files downoaded for this request type."""
      return bool(self.files)

    @property
    def files(self):
        """List of json files for this API request type.
           Not cached, as it will need to be refreshed after a new file has
           been created using self.download().
        """
        files = list(self.dirpath.glob("*.json"))
        files.sort(reverse=True)
        return files

    @property
    def default_filepath(self):
        """Returns a Path object to the file to create."""
        return self.dirpath.joinpath(f"{TODAY}.json")

    @cached_property
    def filepath(self):
        """Returns a Path object to either an existing file or the file to
           create."""
        if self.files:
          return self.files[0]

        return self.default_filepath

    def load(self):
        """Load self.data from the most recent .json file in self.dirpath"""
        if not self.filepath.is_file():
          return

        with self.filepath.open() as fp:
          self.request_data = json.load(fp)

    def download(self):
        """Make a request to the Github API then save the resulting json file.
           Uses the `gh` CLI tool to avoid dealing with authentication.
           Raises CalledProcessError if the request fails.
        """
        result = shell_run(["gh", "api", f"/repos/{USER}/{REPO}/{self.endpoint}"],
                     capture_output=True)
        result.check_returncode()
        data = json.loads(result.stdout.decode())
        with self.filepath.open("w") as fp:
          json.dump(data, fp)


class ChildRequest(GithubRequest):
    """Base class for github requests that need to keep track of their parent
       object."""

    parent: None

    def __init__(self, parent):
        """Initializer
           Assigns self.parent.
        """
        self.parent = parent
        super().__init__()

    def exists(self):
      """Return True if there are files downoaded for this request type."""
      return self.filepath.is_file()

    @property
    def filepath(self):
        """Filename is the `{self.parent.id}.json`.'"""
        return self.dirpath.joinpath(f"{self.parent.id}.json")


class PagesRequest(GithubRequest, Dynamic):
    """Class for github pages requests.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#pages
    """
    dirname: str = "pages"

    @property
    def data(self):
        """Returns a Pages object."""
        return Pages(self.request_data)

    @property
    def endpoint(self):
      """API endpoint following REPO"""
      return "pages"


class StatusRequest(ChildRequest, Finite):
    """Class for deploy status requests.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#get-a-deployment-status
    """
    dirname: str = "statuses"

    @property
    def data(self):
        """Returns list of DeployStatus objects."""
        return [ DeployStatus(x) for x in self.request_data ]

    @property
    def endpoint(self):
      """API endpoint following REPO"""
      return f"deployments/{self.parent.id}/statuses"


class JobsRequest(ChildRequest, Finite):
    """Class for requesting a list of workflow run jobs.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/actions#list-jobs-for-a-workflow-run
    """

    dirname: str = "jobs"

    @property
    def data(self):
        """Set data to a list of Job objects."""
        return [ Job(x, self.parent) for x in self.request_data["jobs"] ]

    @property
    def endpoint(self):
      """The job runs endpoint."""
      return f"actions/runs/{self.parent.id}/jobs"


class CommitRequest(GithubRequest, Static):
    """Class for requesting a commit.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#get-a-commit
    """

    dirname: str = "commits"

    def __init__(self, ref):
        """Initializer
           Assigns self.ref.
        """
        if isinstance(ref, Sha):
          ref = ref.full

        self.ref = ref
        super().__init__()

    @cached_property
    def filepath(self):
      """Filename uses {self.ref}"""
      return self.dirpath.joinpath(f"{self.ref}.json")

    def exists(self):
        """Return True if there are files downoaded for this request type."""
        return self.filepath.is_file()

    @property
    def data(self):
        """Return a Commit object."""
        return Commit(self.request_data)

    @property
    def endpoint(self):
        """deployments endpoint"""
        return f"commits/{self.ref}"


class DeploysRequest(GithubRequest, Additive):
    """Class for requesting a list of deployments.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/repos#deployments
    """

    dirname: str = "deploys"

    @property
    def data(self):
        """Returns a list of Deploy objects."""
        return [ Deploy(x) for x in self.request_data ]

    @property
    def endpoint(self):
      """deployments endpoint"""
      return "deployments"


class RunsRequest(GithubRequest, Additive):
    """Class for requesting a list workflow runs.
       https://docs.github.com/en/free-pro-team@latest/rest/reference/actions#workflow-runs
    """

    dirname: str = "runs"

    @property
    def data(self):
        """Returns a list of Run objects."""
        return [ Run(x) for x in self.request_data["workflow_runs"] ]

    @property
    def endpoint(self):
      """Runs endpoint."""
      return "actions/runs"


def debug(app):
    deploys = DeploysRequest()
    statuses = StatusRequest(deploys.data[0])
    runs = RunsRequest()
    run = runs.data[0]
    job = run.jobs[0]
    step = job.steps[0]
    commit_req = CommitRequest("dfe4c0a60db827a8576bb510f99d574f9a42be4d")
    commit = commit_req.data
    status = Status("success")
    progress = Progress("completed")

    app.info(DATA_DIR, name="DATA_DIR")
    app.info(deploys.dirname, name="deploys.dirname")
    app.info(deploys.dirpath, name="deploys.dirpath")
    app.info(deploys.filepath, name="deploys.filepath")
    app.info(deploys.endpoint, name="deploys.endpoint")
    app.info(deploys.data[0], name="Deploy")

    app.info(statuses.dirname, name="statuses.dirname")
    app.info(statuses.dirpath, name="statuses.dirpath")
    app.info(statuses.filepath, name="statuses.filepath")
    app.info(statuses.endpoint, name="statuses.endpoint")
    app.info(statuses.data[0], name="DeployStatus")

    app.info(runs.dirname, name="runs.dirname")
    app.info(runs.dirpath, name="runs.dirpath")
    app.info(runs.filepath, name="runs.filepath")
    app.info(runs.endpoint, name="runs.endpoint")
    app.info(runs.data[0], name="Run")

    app.info( run.jobs_request.dirname, name="jobs.dirname")
    app.info( run.jobs_request.dirpath, name="jobs.dirpath")
    app.info(run.jobs_request.filepath, name="jobs.filepath")
    app.info(run.jobs_request.endpoint, name="jobs.endpoint")
    app.info(job, name="Job")

    app.info( run.jobs_request.dirname, name="jobs.dirname")
    app.info( run.jobs_request.dirpath, name="jobs.dirpath")
    app.info(run.jobs_request.filepath, name="jobs.filepath")
    app.info(run.jobs_request.endpoint, name="jobs.endpoint")
    app.info(step, name="Step")
    app.info(commit, name="Commit")
    app.info(Ok.ok, name="Ok")
    app.info(status, status.ok, name="Status")
    app.info(progress, progress.ok, name="Progress")


# TODO: Format pages status
# TODO: Add pages build info
@click.command()
@click.option("--local", "-l", is_flag=True, default=False,
              help="Don't download updates, even for pending states.'")
@click.option("--refresh", "-r", is_flag=True, default=False,
              help="Download updates.")
@click.option("--verbose", "-v", is_flag=True, default=False,
              help="Enable verbose mode.")
def cli(**kwargs):
    """Show status information about Gihub Pages and Actions"""
    # debug(app)
    app = Object.APP = GithubRequest.APP = App(**kwargs)

    pages = PagesRequest()
    deploys = DeploysRequest()
    runs = RunsRequest()

    # app.info(pages.data, name="Pages")

    rows = []
    for run in runs.data:
        deploy = run.deploy(deploys.data)
        rows.append({
            "#": run.number,
            "OK": app.style.status(run.status),
            "date": run.date,
            "id": run.id,
            "commit": run.sha,
            "message": run.message.splitlines()[0][0:40],
            "job": app.style.job(run.last_job),
            "deploy": f"{app.style.status(deploy.status)} {deploy.sha}" if deploy else ""
        })

    print(app.style.header("Github Action Runs"))
    print(tabulate(rows, headers="keys"))

    rows = []
    for deploy in deploys.data[:5]:
        rows.append({
            "OK": app.style.status(deploy.status),
            "date": deploy.date,
            "id": deploy.id,
            "commit": deploy.sha,
            "master": deploy.master_sha or " "*Sha.SHORT_LENGTH,
            "message": deploy.message.splitlines()[0][0:50],
        })

    print(app.style.header("Deploys"))
    print(tabulate(rows, headers="keys"))


if __name__ == "__main__":
    cli()
